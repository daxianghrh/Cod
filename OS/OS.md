# OS

## 1、进程调度策略？

进程调度策略是操作系统用于决定在多道程序环境中哪个进程将被分配CPU执行的算法。常见的进程调度策略包括：

1. 先来先服务（First-Come, First-Served，FCFS）：按照进程到达的顺序进行调度，即先到达的进程先执行。

2. 最短作业优先（Shortest Job Next，SJN）：选择估计执行时间最短的进程进行执行。也可以是实际执行时间最短的进程（最短剩余时间优先，Shortest Remaining Time First，SRTF）。

3. 优先级调度（Priority Scheduling）：为每个进程分配一个优先级，优先级高的进程先执行。可以是静态优先级，由进程的属性或固定设置决定，也可以是动态优先级，根据进程的行为和需求动态调整。

4. 时间片轮转（Round-Robin，RR）：按照预先设定的时间片大小（时间量子），轮流将CPU分配给每个进程，如果进程在一个时间片内未执行完，则放回就绪队列尾部继续等待。

5. 多级反馈队列调度（Multilevel Feedback Queue，MLFQ）：将就绪队列分成多个优先级队列，每个队列使用不同的调度算法，例如时间片轮转和优先级调度的结合。根据进程的行为和需求，进程可以在不同队列间移动。

6. 最高响应比优先（Highest Response Ratio Next，HRRN）：根据进程的响应比（等待时间加服务时间除以服务时间），选择响应比最高的进程进行执行。

7. 多处理器调度：针对多个处理器系统，将进程分配给多个处理器以实现并行执行。可以使用上述调度策略的变种。

以上是一些常见的进程调度策略，不同的调度策略适用于不同的场景和需求。实际操作系统通常会使用一种或多种调度策略的组合来实现更好的性能和资源利用。

## 2、FreeRtos进程调度策略？

FreeRTOS 是一个流行的实时操作系统 (RTOS)，用于嵌入式系统开发。在 FreeRTOS 中，进程被称为任务（task）。FreeRTOS 提供了几种任务调度策略，以满足不同的实时需求和应用场景。

以下是 FreeRTOS 中常见的任务调度策略：

1. 抢占式调度（Preemptive Scheduling）：
   - 默认的任务调度策略是抢占式调度，也被称为优先级抢占式调度。
   - 在抢占式调度中，每个任务都有一个优先级，并且具有较高优先级的任务可以打断正在执行的较低优先级任务。
   - 当一个优先级更高的任务准备就绪时，它会立即抢占正在执行的任务，并开始执行。
   - 抢占式调度使得高优先级任务能够及时响应，并保证了系统对实时任务的及时性响应。

2. 协作式调度（Cooperative Scheduling）：
   - FreeRTOS 也支持协作式调度，通过任务主动让出 CPU 来实现任务之间的切换。
   - 在协作式调度中，任务需要显式地调用任务切换函数（如 `taskYIELD()`）来让出 CPU。
   - 任务切换只会在任务自愿让出 CPU 时发生，因此需要确保任务之间合作良好，避免长时间占用 CPU 导致系统无法响应其他任务。

3. 时间片轮转调度（Time Slicing）：
   - FreeRTOS 还支持时间片轮转调度，可与抢占式调度结合使用。
   - 在时间片轮转调度中，每个任务被分配一个固定的时间片，任务在时间片内执行，然后让出 CPU 给下一个任务。
   - 如果任务在时间片结束前未完成，它将被放回就绪队列的末尾，并等待下一次调度。

需要注意的是，FreeRTOS 可以根据实际需求和配置进行灵活的调度策略选择和配置。可以通过配置文件或 API 函数进行任务优先级、调度策略、时间片大小等的设置和调整。

以上是 FreeRTOS 中常见的任务调度策略。选择合适的调度策略取决于应用程序的实时需求、响应性要求和系统资源。

## 3、Linux进程调度策略？

Linux的进程调度是指操作系统决定在多道程序环境中，哪个进程将被分配CPU资源进行执行。Linux的进程调度是一个复杂的机制，旨在提供高效的资源利用和良好的响应性能。

Linux的进程调度具有以下特点和机制：

1. 多级反馈队列调度（Multilevel Feedback Queue，MLFQ）：
   - Linux使用多级反馈队列调度策略，将进程按照优先级分组，并为每个组分配不同的时间片大小。
   - 高优先级的进程可以使用较小的时间片，从而更快地获得CPU资源。
   - 低优先级的进程则使用较大的时间片，以免长时间占用CPU。

2. 动态优先级调度：
   - Linux的进程调度是动态的，进程的优先级可以根据不同的条件和行为进行调整。
   - 进程的优先级可以根据进程等待时间、CPU使用时间、IO操作等进行动态调整，以提供公平的资源分配。

3. 实时调度：
   - Linux提供了实时调度策略，用于对实时任务进行特殊处理，以确保它们能够按时得到响应。
   - 实时调度分为FIFO（先进先出）和RR（轮转）两种调度策略，它们针对实时任务提供了保证性能和响应性的保障。

4. CFS调度器：
   - Linux的默认调度器是完全公平调度器（Completely Fair Scheduler，CFS）。
   - CFS调度器通过计算每个进程的虚拟运行时间来进行调度决策，以实现对CPU时间的公平分配。
   - CFS调度器旨在提供良好的响应性能和资源利用率。

5. 实时时钟：
   - Linux使用实时时钟（tickless timer）来跟踪时间，而不是每个时钟滴答都触发中断。
   - 这种实时时钟的使用减少了中断处理开销，并提高了系统的响应性。

需要注意的是，Linux的进程调度是高度可配置的。可以通过调整调度器参数、优先级、策略等进行微调和定制，以满足特定应用需求。

总体而言，Linux的进程调度采用多级反馈队列调度、动态优先级调度和实时调度等策略，旨在提供高效的资源利用、公平性和响应性能。它的灵活性和可配置性使得它适应了各种不同的应用场景和需求。

## 4、谈一谈虚拟内存地址和物理内存地址？

-  程序所使用的内存地址叫做**虚拟内存地址**。
-  实际存在硬件里面的空间地址叫**物理内存地址**。

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。

## 5、操作系统是如何管理虚拟地址与物理地址之间的关系的？

两种方式：分段和分页

### 分段

程序是由若干个逻辑段组成的，如可由**代码分段、数据分段、栈段、堆段**组成。不同的段是有不同的属性的，所以就用**分段**的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成：**段选择因子**和**段内偏移量**。

段选择因子和段内偏移量：

-  段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。

-  虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

> 分段的不足之处？

-  **内存碎片**: 不会产生内部内存碎片，会产生外部内存碎片。
-  **内存交换的效率低**：解决外部内存碎片就是**内存交换**，Linux中的**Swap**空间就是内存交换空间。硬盘的访问速度要比内存的慢很多，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。

### 分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫`页（Page）`。在 Linux 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射。

页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常(Page Fault)**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

> 分页是如何解决分段的「外部内存碎片和内存交换效率低」的问题？

-  采用分页方式，页与页之间是紧密排列的，所以不会有外部碎片。但是分页机制分配内存的最小单位是一页，即使程序不足一页时，也要分配一页内存，所以会产生内部内存碎片。
-  若内存空间不够，操作系统会把其他正在进行中的进程中的[最近没被使用]的内存页面写到磁盘上，成为**换出(Swap Out)**;需要时在**换入(Swap In)**。一次写入磁盘的页只有少数的一个页或多页，内存交换的效率就相对比较高。

> 分页机制下，虚拟地址和物理地址是如何映射的？

在分页机制下，虚拟地址分为两部分，**页号和页内偏移**。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。

> 简单的分页有什么缺陷？

有空间上的缺陷。

在32位机器下，虚拟地址空间有`4GB`，假设一个页大小为`4KB`,那么需要100万(2^20)个页表项，每个[页表项]需要4个字节来存储，那么整个`4GB`空间的映射需要`4MB`的内存来存储页表。若是100个进程，则需要`400MB`内存来存储页表，这是非常大的内存。

#### 多级页表

要解决上面的问题，就需要采用一种叫作`多级页表（Multi-Level Page Table）`的解决方案。

在前面我们知道了，对于单页表的实现方式，在 `32 `位和页大小 `4KB` 的环境下，一个进程的页表需要装下 100 多万个[页表项]，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。

我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。


>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？

当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。

其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？

每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。

如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？

那么为什么不分级的页表就做不到这样节约内存呢？

我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。

我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。

#### TLB 

多级页表虽然解决了空间上的问题，但是从虚拟地址转换到物理地址多了几道转换的工序，降低了转换速度。

利用程序执行的**局部性原理**，把最常访问的几个页表项存储到访问速度更快的硬件中，即`TLB，后备缓冲区`，`CPU`中专门存放程序最常访问的页表项的`Cache`。

这样在虚拟地址转换到物理地址时，`MMU`先查询`TLB`,若无，才会继续查找页表。

## 6、Linux内存分布

Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。

**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。**

## 7、谈一谈虚拟内存的作用？

-  进程间隔离的作用：虚拟内存使每个进程都有自己的虚拟地址空间和页表，一个进程无法访问其他进程的页表，解决了多进程之间的地址冲突问题。
-  虚拟内存可以让进程运行内存超过实际物理内存的程序大小，换入换出。

