# 第三章 字符串、向量和数组

 

## 3.2 标准库类型string

### 3.3.2 string对象上的操作

| string的操作  |                                                              |
| :------------ | ------------------------------------------------------------ |
| os<<s         | 将s写到输出流os中，返回os                                    |
| is>>s         | 从is中读取字符串赋值给s，字符串以空白分隔，返回is            |
| <,<=,>,>=     | 利用字符在字典中的顺序进行比较，string对象对**字母的大小写**敏感 |
| getline(is,s) | 从is中读取一行复制给s，返回is                                |

#### 使用getline读取一整行

若希望得到的字符串中保留输入时的空白符，使用getline函数代替>>运算符。getline函数从给定的输入流中读入内容，直到遇到换行符为止（**注意换行符也被读进来了**），然后把所读内容赋值给string对象（注意不存换行符）。

#### string::size_type类型

对于size函数，返回一个int或者unsigned似乎是合情合理，但其实size函数返回的是string::size_type类型的值。size_type是一个无符号类型的值而且能足够存放任何string对象的大小，所有用来存放string类的size函数返回值的变量，都应该是该类型。！！！**注：若一条表达式中已经有了size函数就不要使用int来接受size函数返回的变量，这样可以避免混用int和unsigned带来的问题**！！！如：n是一个具有负值的int，则表达式s.size（）<n判断结果几乎肯定是true，因为负数n会自动转换成一个比较大的无符号值。

#### 字面值和string对象相加

注：当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少一个是string:

```c++
string s6=s1+","+"world";//正确：每个加法运算符都有一个运算对象是string
string s7="hello"+","+s2;//错误：不能把字面值直接相加
```

！！！注：为了与C兼容，**C++语言中的字符串字面值并不是标准库类型string的对象**。

### 3.2.3 处理string对象中的字符

如下标准库函数可以对string对象中的字符进行处理：

| 函数        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| isalnum(c)  | 当c是字母或数字时为真                                        |
| isalpha(c)  | 当c是字母时为真                                              |
| isdigit(c)  | 当c是十进制数字时为真                                        |
| islower(c)  | 当c是小写字母时为真                                          |
| isupper(c)  | 当c是大写字母时为真                                          |
| isxdigit(c) | 当c是十六进制数字时为真                                      |
| tolower(c)  | 若c是大写字母，输入对应的小写字母；否则原样输出              |
| toupper(c)  | 若c是小写字母，输入对应的大写字母；否则原样输出              |
| isspace(c)  | 当c为标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种) |

#### 处理每个字符？使用基于范围的for语句

C++11新标准提出了**一种基于范围的for语句**，该语句遍历给定序列中的每个元素并对序列中的每个值的执行某种操作，其语法形式是：

```c++
for(declaration:expression){
	statement
}
```

其中expression部分是一个对象，用于表示一个序列；declaration部分负责定义一个变量，该变量被用于访问序列中的基本元素；每次迭代，declaration部分的变量都会被初始化为expression部分的下一元素值。例：string对象表示一个字符的序列，可以作为expression部分，下面代码段把string对象str中的字符一次打印出来。

```c++
string str("some thing");
for(auto c:str){ //关键词auto判断c的类型 为char
    cout<<c<<endl;
}
```

#### 使用范围for语句改变字符串中的字符

若向改变string对象中字符的值，必须把循环变量定义成引用类型。所谓引用就是给定对象的一个别名，引用绑定在给定对象上，使用引用作为变量时，对引用的操作就是对给定对象的操作，进而可以改变给定对象的值。

```c++
for(auto &c:str){
	c=toupper(c);//c是引用，赋值将改变s中字符的值
}
cout<<str<<endl;//str输出为“SOME THING”
```

注：for语句的条件部分涉及一点新知识,逻辑与(&&)。**C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。**

## 3.3 标准库类型vector

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。**编译器根据模板创建类或函数的过程称为实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

vector是一个类模板，对于类模板我们需要提供一些额外消息来指定模板到底实例化成什么样的类，需要提供哪些消息由模板决定。**方式为：在模板名字后面跟一对尖括号，在括号内放上信息。**如：

```c++
vector<int> ivec;//ivec保存int类型对象
vector<Sales_item> Sales_vec;//Sales_vec保存Sales_item类型对象
vector<vector<string>>file;//file保存vector对象
```

注：vector虽能容纳绝大数类型的对象作为元素，但是不可以包含**引用**，因为引用不是对象。

## 3.4 迭代器介绍

我们直到可以通过下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制可以实现同样的目的，就是**迭代器（iterator）**。标准库下定义的几种容器都可以使用迭代器，但是其中只有几种才同时支持下标运算符。！！！注：严格来说，string对象不属于容器类型，但是string支持与容器类型类似的操作。

### 3.4.1 使用迭代器类型

#### 迭代器类型

拥有迭代器的标准库类型使用iterator和const_iteratorl来表示迭代器的类型。iterator类型能读写元素，而const_iteratorl仅能读元素，不可写元素。如：

```c++
vector<int>::iterator it;//it能读写vector<int>的元素
vector<int>::const_iterator it2;//it2仅能读vector<int>的元素，不能写元素
```

**const_iteratorl和常量指针类似**，能读取但不能修改它所指的元素值。若vector对象是一个常量，只能使用const_iteratorl；若不是常量，既可以使用iterator又可以使用const_iteratorl。

#### begin和end运算符

begin和end返回的具体类型由对象是否是常量决定。若是常量，返回const_iteratorl；若不是常量，返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto it1=v.begin();//it1类型是vector<int>::iterator
auto it2=v.end();//it2类型是vector<int>::const_iterator
```

C++11新标准引入了两个新函数，cbegin和cend函数，与begin和end函数不同的是，不论对象是否是常量返回的都是const_iteratorl。

```c++
auto it3=v.cbegin();//it3类型是vector<int>::const_iterator
```

#### 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象。例：一个由字符串组成的vector对象来说，要想检查元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码为：

```c++
(*it).empty();
 it->empty();//两者表达意思一样
```

#### 某些对vector对象的操作会使迭代器失效

虽然vector对象可以动态地增长，但是也会有副作用。第一个限制是不能在范围for循环中向vector容器添加元素；第二个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。**！！！注：但凡使用了迭代器的循环体，都不可以向迭代器所属的容器中添加元素。**

## 3.5 数组
