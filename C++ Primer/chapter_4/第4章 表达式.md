# 第4章 表达式

## 4.1 基础

### 4.1.1 基本概念

#### 左值和右值

C++的表达式要不然是**右值**，要不然是**左值**，这两个名词是从C语言继承过来的，左值可以位于赋值语句的左侧，右值则不能。

在C++语言中，二者的区别就没那么简单了。**一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象**。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。简单归纳：当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值时，用的是对象的身份(在内存中的位置)。

不同运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到右值结果。一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值(也就是在内存中的位置)。当一个左值被当成右值使用时，实际使用的是它的内容。

| 运算符                                                       | 需要的运算对象         | 返回结果                                   |
| :----------------------------------------------------------- | ---------------------- | ------------------------------------------ |
| 赋值运算符                                                   | 左值作为其左侧运算对象 | 左值                                       |
| 取地址符                                                     | 左值运算对象           | 返回一个指向该运算对象的指针，该指针为右值 |
| 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符 | 左值                   | 左值                                       |
| 内置类型和迭代器的递增递减运算符                             | 作用于左值运算对象     | 左值                                       |

接下来介绍运算符时，会注明该运算符的运算对象是否必须是左值以及求值结果是否是左值。

使用关键字decltype的时候，左值和右值有所不同。如表达式的求值结果是左值，decltype作用与该表达式(不是变量)得到一个引用类型。例如，假设p的类型是int *，因为解引用运算符生成左值，所以decltype(*p)的结果是int &;另一方面，因为取址运算符生成右值，所以decltype(&p)的结果是int **，也就是说，结果是一个指向整形指针的指针。

### 4.1.3 求值顺序

优先级规定了运算对象的组合方法，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。举个简单的例子，<<运算符没有规定何时以及如何对运算对象求值，因此下面输出表达式是未定义的:

```C++
int i=0;
cout<<i<<""<<++i<<endl;
```

因为程序是未定义的，所有我们无法推断它的行为。编译器可能先求++i的值再求i的值，此时输出结果未1 1；也有可能先求i的值在求++i的值，输出结果为 0 1；甚至编译器还可能做完全不同的操作。因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

#### 求值顺序、优先级、结合律

运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中对其中的函数调用顺序没有明确规定。若f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制；**反之，若其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。**

## 4.2 算术运算符

在表达式求值前，小整数类型的运算对象会被提升为较大的整数类型，所有运算对象最终会被转换成同一类型。

对大多数运算符来说，布尔类型的运算对象被提升为int类型。如布尔变量b为真，参与运算时将被提升为整数值1，对它求负后的结果为-1。将-1转换成布尔值并将其作为b2的初始值，显然这个初始值不为0，转换成布尔值后应该为1。所以，b2的值是真！

```c++
bool b=true;
bool b2=-b;
```

！！！注：溢出和其他算术运算异常：

```c++
 //溢出 short类型占16位 最大值为32767 最小值为-32768
    short short_value=32767;
    short_value+=1; //值发生“环绕”，符号位本来为0，由于溢出变为1，于是结果变为一个负值
    cout<<short_value<<endl;
```

C++新标准中除了-m导致溢出的特殊情况，其他时候**(-m)/n和m/(-n)都等于-(m/n)**,**m%(-n)等于m%n,(-m)%n等于-(m%n)。**

## 4.4 赋值运算符

赋值运算符的左侧对象必须是**一个可修改的左值**。

赋值运算的结果是它的左侧运算对象，并且是一个左值，相应的，结果的类型就是左侧运算对象的类型。若赋值运算符的左右两个运算对象类型不同，则右侧运算对象会将转换成左侧运算对象的类型。例：

```c++
int k=0;
k=0;//结果：类型是int，值为0
k=3.14159;//结果：类型是int，值为3
```

C++11标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。**若左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占的空间也不应该大于目标类型的空间。**例：

```c++
k={3.14};//错误：double型转成int  窄化转换
```

#### 赋值运算符满足右结合律

```c++
int ival,jval;
ival=jval=0;
```

因为赋值运算符满足右结合律，所以靠右的赋值运算jval=0作为靠左的赋值运算符的右侧运算对象，又因为赋值运算返回的是其左侧运算对象，所以靠右的赋值运算的结果被赋给ival。

对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到。

```c++
int ival2,*p;
ival2=p=0;//错误：不能把指针的值赋给int
string s1,s2;
s1=s2="OK";
```

#### 赋值运算符的优先级较低

注：赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。

## 4.5 递增和递减运算符

递增和递减运算符有两种形式：前置版本和后置版本 。**前置版本形式的运算符首先将运算对象加1(或减1)，然后将改变后的对象作为求值结果；后置版本形式的运算符也会将运算对象加1(或减1)，但是求值结果是运算对象改变之前那个值的副本**：

```c++
 int ival3=0,j=0;
 j=++ival3;
 cout<<j<<ival3<<endl;//j=1,ival3=1:前置版本得到递增之后的值
 j=ival3++;
 cout<<j<<ival3<<endl;//j=1,ival=2:后置版本得到递增之前的值
```

这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。

**！！建议：除非必须，否则不用后置版本。**因为前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象，与之相比，后置版本需要将原始值存储下来以便返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。

#### 在一条语句中混用解引用和递增运算符

若我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。例如，使用后置的递增运算符来控制循环输出一个vector对象内容直至遇到(但不包括)第一个负值为止:

```c++
auto pbeg=v.begin();
while(pbeg!=v.end()&&*pbeg>=0){
    cout<<*pbeg++<<endl;//输出当前值并将pbeg向前移动一个元素
}
```

后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为求值结果，此时解引用运算符的对象是pbeg未增加前的值。最终输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。

## 4.6 成员访问运算符

点运算符和箭头运算符都可用于访问成员，其中点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*ptr).mem；

解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。箭头运算符作用于一个指针类型的运算对象，结果是一个左值；点运算符根据成员所属的对象产生结果，若对象是左值，结果是左值，反之，为右值。

练习：假设iter是vector<string>::iterator类型，说明下表中的表达式是否合法。

| 表达式          | 是否合法                                                     |
| --------------- | ------------------------------------------------------------ |
| *iter++;        | 合法。后置递增运算符的优先级比解引用优先级高，指向原始vector<string>位置，然后迭代器加1。 |
| (*iter)++;      | 不合法。string对象没有重载++运算符                           |
| *iter.empty()   | 不合法。点运算符优先级高于解引用运算符，iter是一个指针，指针没有empty成员函数。 |
| iter->empty()   | 合法。iter->empty()等价于(*iter).empty()，iter解引用是string对象，有成员函数。 |
| ++*iter         | 不合法。                                                     |
| iter++->empty() | 合法。箭头运算符优先级高于后置递增运算符，等于iter->empty(),iter++; |

```c++
 vector<string>s={"a","b","c"};
    vector<string>::iterator iter=s.begin();
    *iter++;
    //(*iter)++;不合法
    //*iter.empty();不合法
    iter->empty();
    //++*iter;不合法
    iter++->empty();  // iter->empty()，iter++;
```

## 4.7 条件运算符

条件运算符(?：)允许把简单的if-else嵌入到单个表达式中，条件运算符形式如下：

```c++
cond?expr1:expr2;
```

