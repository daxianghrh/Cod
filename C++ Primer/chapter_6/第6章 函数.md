# 第6章 函数

## 6.1 函数基础

一个典型的函数定义包括以下部分：**返回类型、函数名字、由0个或多个形参组成的列表以及函数体。**

通过**调用运算符**来执行函数。**调用运算符的形式是一对圆括号**，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参列表，用它来初始化函数的形参。调用表达式的类型就是函数的返回类型。

### 6.1.1 局部对象

C++语言中，名字有作用域，对象有生命周期。

名字的作用域是程序文本的一部分，名字在其中可见。

对象的生命周期是程序执行过程中该对象存在的一段时间。

#### 自动对象

对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。**我们把只存在于块执行期间的对象称为自动对象**。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。形参就是一种自动对象。

对于局部变量对应的自动对象来说，分为两种情况：若变量定义本身含有初始值，就用这个初始值进行初始化；否则，若本身不含初始值，执行默认初始化，意味着内置类型的未初始化局部变量将产生未定义的值。

#### 局部静态对象

某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义成static类型从而获得这样的对象。**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。**若局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0；**

##  6.2 参数传递

### 6.2.1 传值参数

| 形参类型         | 对实参的影响                                                 |
| ---------------- | ------------------------------------------------------------ |
| 非引用类型的形参 | 实参的值被拷贝给形参，对形参变量的改动不会影响实参的值。     |
| 指针类型的形参   | 和非引用类型的形参一样，实参指针的值被拷贝给形参，指向的对象相同，所以通过指针的解引用操作修改所指对象的值，即会影响实参的值。 |
| 引用类型的形参   | 引用类型的形参绑定在实参对象上，是实参对象的一个别名，修改形参的值就是修改实参的值。 |

#### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括IO类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

例如，编写一个函数比较两个string对象的长度，因为string对象可能会非常长，所以应该避免直接拷贝它们，这时使用引用形参比较明智。有因为无须改变string对象的内容，所以把形参定义成对常量的引用：

```c++

bool isShorter(const string &s1,const string &s2){
    return s1.size()<s2.size();
}
```

**当函数无须修改引用形参的值时最好使用常量引用。**

####  使用引用形参返回额外信息

一个函数只能返回一个值，然而有时需要同时返回多个值，引用参数为我们一次返回多个结果提供了有效途径。例如，定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置，同时希望函数返回该字符出现的总次数。

如何定义函数使它既能返回位置也能返回出现次数呢?一种方法是定义一个新的数据类型，让它包含位置和数量两个成员；还有一种是，**我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数**:

```c++
//返回s中字符c第一次出现的位置索引
//引用形参occurs负责统计c出现的总次数
string::size_type find_char(const string &s,char c,string::size_type &occurs){
    auto ret=s.size();//若s中没有c 返回s的长度
    occurs=0;
    for(decltype(ret) i=0;i!=s.size();++i){
        if(s[i]==c){
            if(ret==s.size()){
                ret=i; //记录c第一次出现的位置
            }
            ++occurs;
        }
    }
    return ret; //出现次数通过occurs隐式地返回
}



int main(){
    string s="hhhhheeellohhafsdfsag";
    char c='h';
    string::size_type str;
    auto index=find_char(s,c,str);
    cout<<"字母:"<<c<<"出现次数为："<<str<<endl;
}
```

### 6.2.3 const形参和实参

当形参是const时，必须注意顶层const，顶层const作用于对象本身：

```c++
const int ci=42;
int i=ci;//正确：当拷贝ci时，忽略了它的顶层cosnt
int * const p=&i;//正确：const是顶层的 不可以给p赋值
*p=0;//正确，通过p该变对象的内容是允许的，i=0
```

**和其他初始化过程一样，当用实参初始化形参时忽略掉顶层const。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。**

```c++
void fcn(const int i){
	//fcn能够读取i,但是不能向i写值
}
```

调用fcn函数时，既可以传入const int，也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```c++
void fcn(const int i){}
void fcn(int i){} //错误：重复定义了fcn(int)
```

因为顶层const被忽略了，所以上面的代码中传入了两个fcn函数的参数一样。

#### 指针或引用形参与const

形参的初始化方式和变量的初始化方式是一样的。如我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。

```c++
int i=42;
const int *cp=&i;//正确：cp不可以改变i
const int &r=i;//正确：r不可以改变i
const int &r2=42;//正确：可以用字面值初始化常量引用
int *p=cp;//错误：cp是const int * ,p是int *,类型不匹配
int &r3=r;//错误：r是const int &,r3是int &,类型不匹配
int &r4=42;//错误：不能用字面值初始化一个非常量引用
```

将同样的变量初始化规则应用到参数传递上可得:

```C++
int i=0;
const int ci=i;
string::size_type ctr=0;
reset(&i);//调用形参是int*的reset函数
reset(&ci);//错误：不能用指向const int对象的指针初始化int *

reset(i);//调用形参为int&的reset函数
reset(ci);//错误：不能把普通引用绑定在const对象ci上
reset(42);//错误：不能把普通引用绑定在字面值上
reset(ctr);//错误：类型不匹配，ctr是无符号类型
```

若想调用引用版本的reset函数，实参只能是int类型的对象；调用指针版本的reset函数，实参只能是int*类型的对象。

#### 尽量使用常量引用

把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。**此外，使用引用而非常量引用也会极大的限制函数所能接受的实参类型。就像上面所说，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。**

例如，以6_15.cpp中的find_char函数将它的string类型的形参定义成常量引用。假如我们把它定义成普通的string&，那么只能将find_char函数作用于string对象。

```c++
string::size_type find_char(string &s,char c,string::size_type &occurs){
    /*   */
}

auto index=find_char("Hello",'o',ctr);//编译时错误，因为不能将普通string对象引用绑定在字面值上
```

还有一个更难察觉的问题，假如其他函数(正确地)将它们的形参定义成常量引用，那么第二个版本的find_char无法在此类函数中正常使用。如，我们希望在一个判断string对象是否是句子的函数中使用find_char：

```c++
bool is_sentence(const string &s){
    //若在s的末尾有且仅有一个句号，则s是一个句子
    string::size_type ctr=0;
    return find_char(s,'.',ctr)==s.size()-1&&ctr==1;
}
```

如果find_char的第一个形参类型是string&，那么上面调用find_char的语句将在编译时发生错误。原因时s时常量引用，但find_char被不正确地定义成只能接受普通引用。

### 6.2.4 数组形参

**如果传给函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。**

因为数组是以指针的形式传递给函数的，所以一开始函数并不直到数组的确切尺寸，调用者应该为此提供一些额外的消息。管理指针形参有三种常用形式的技术。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身含有一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符('\0')。函数在处理C风格字符串时停止：

```C++
void print(const char *cp){
    if(cp){
        while(*cp){ //指针所指的字符不是空字符
            cout<<*cp++;
        }
    }
}
```

#### 使用标准库规范

第二种方法是传递数组首元素和尾后元素的指针。

```c++
void print(const int *begin,const int *end){
    while(beg!=end){
        cout<<*beg++<<endl;
    }
}
```

#### 显式传递一个表示数组大小的形参

第三种方法是专门定义一个表示数组大小的形参。

```c++
//const int ia[]等价于const int *ia
//size表示数组的大小，将它显式地传递给函数用于控制对ia元素的访问
void print(const int *ia,size_t size){
    for(size_t i=0;i!=size;++i){
       cout<<ia[i]<<endl;
    }
}
```

### 6.2.5 mian : 处理命令行选项

 目前为止，我们定义的main函数都只有空形参列表:

```c++
int main(){ ...}
```

然而，有时我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数要执行的操作。例如，假定main函数位于可执行文件prog之内，我们可以向程序传递下面的选项：

```c++
prog -d -o ofile data0
```

这些命令通过两个(可选的)形参传递给main函数：

```c++
int main(int argc,char *argv[]){...}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。当实参给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

以上面提供的命令行为例，argc应该等于5，argv应该包含如下的C风格字符串：

```c++
argv[0]="prog";//或者argc[0]也可以指向一个空字符串 使用argv中的实参时从argv[1]开始
argv[1]="-d";
argv[2]="-o";
argv[3]="ofile";
argv[4]="data0";
argv[5]=0;
```

### 6.2.6 含有可变形参的函数

有时我们无法提前预知应该向函数传递几个形参。例如，我们想要编写代码输出程序产生的错误信息，此时最好使用同一个函数实现该项功能，以便对所有错误的处理能够整齐划一。然而，错误信息的种类不同，所以调用错误输出函数时传递的实参也各不相同。

为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:

**1、如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。**

**2、如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，将在16.4节介绍。**

C++还有一种特殊的形参类型即省略符，可以用它传递可变数量的实参，这种功能一般只用于与C函数交互的接口程序。

#### initalizer_list形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initalizer_list类型的形参，它时一种标准库类型，用于表示某种特定类型的值的数组。

initializer_list也是一种模板类型，定义initializer_list对象时，必须说明列表中所含元素的类型。注：initializer_list对象中的元素永远是常量值，无法改变initializer_list对象中元素的值。

```c++
initializer_list<T> lst;//模板
initializer_list<string> ls;//initializer_list的元素类型是string
initializer_list<int> li;//initializer_list的元素类型是int
```

#### 省略符形参

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符不应用于其他目的。

省略符形参只能出现在形参列表的最后一个位置，它的形式为以下两种：

```c++
void foo(param_list,....);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对于这些形参的实参将会执行正常的类型检测。省略符形参所对应的实参无须类型检查。