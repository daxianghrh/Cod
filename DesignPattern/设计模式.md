# 常见设计模式

## 单例模式

保证全局只有一个类的实例，通常将类的构造函数设置为私有，通过类的`static`成员函数获得类的实例。

```cpp
class SinglePattern {
public:
    static SinglePattern& getInstance() {
        //静态局部变量
        static SinglePattern sp;
        return sp;
    }

private:
    //构造函数声明为private,只允许类内部调用
    SinglePattern() {}
    SinglePattern(const SinglePattern& sp) = delete;
    SinglePattern& operator= (const SinglePattern& sp) = delete;
};
```

>单例模式的懒汉模式和饿汉模式?

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点以访问该实例。单例模式在很多情况下都能够提供有效的解决方案，比如全局配置管理、线程池、数据库连接池等。

在单例模式中，有两种主要实现方式：懒汉模式（Lazy Initialization）和饿汉模式（Eager Initialization）。

**1. 懒汉模式：**

懒汉模式是指在第一次使用实例时才创建它。懒汉模式有两种常见的实现方式：使用互斥锁实现线程安全的延迟加载，或者利用静态变量的特性实现。

懒汉模式的优点是节约资源，只有在需要的时候才会创建实例。然而，需要注意在多线程环境下需要进行线程安全处理，以避免多个线程同时创建实例。

**2. 饿汉模式：**

饿汉模式是指在类加载时就创建实例，即在静态成员初始化阶段就完成了实例的创建。由于实例在类加载时就已经创建好，所以不存在线程安全问题。

饿汉模式的优点是简单明了，不需要考虑线程安全问题。但如果实例的创建和初始化比较耗时，可能会导致程序启动较慢。

下面是懒汉模式和饿汉模式的示例：

**懒汉模式示例：**

```cpp
#include <iostream>
#include <mutex>

class LazySingleton {
private:
    static LazySingleton* instance;
    static std::mutex mtx;

    LazySingleton() {}

public:
    static LazySingleton* getInstance() {
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mtx);
            if (instance == nullptr) {
                instance = new LazySingleton();
            }
        }
        return instance;
    }
};

LazySingleton* LazySingleton::instance = nullptr;
std::mutex LazySingleton::mtx;

int main() {
    LazySingleton* singleton = LazySingleton::getInstance();
    return 0;
}
```

**饿汉模式示例：**

```cpp
#include <iostream>

class EagerSingleton {
private:
    static EagerSingleton* instance;

    EagerSingleton() {}

public:
    static EagerSingleton* getInstance() {
        return instance;
    }
};

EagerSingleton* EagerSingleton::instance = new EagerSingleton();

int main() {
    EagerSingleton* singleton = EagerSingleton::getInstance();
    return 0;
}
```

在实际应用中，您可以根据需求选择懒汉模式或饿汉模式来实现单例模式。选择哪种方式取决于您的应用场景和性能需求。

## 工厂模式

-   简单工厂模式
-   工厂方法模式
-   抽象工厂模式

作用：封装对象的创建过程，不直接暴露对象的创建逻辑。提供一种将对象的实例化过程与客户端代码解耦的方式。

主要思想：通过一个工厂类来封装对象的创建，客户端代码与工厂类进行交互，不需要了解实际的对象创建细节。

### 简单工厂模式

简单工厂模式并不是一个正式的设计模式，而是一种简化对象实例化过程的方法。在简单工厂模式中，**有一个工厂类，根据传入的参数或条件，选择性地创建并返回不同类的对象**。客户端通过向工厂请求对象来获取所需的实例。

```cpp
/**
*@brief 简单工厂模式
*
*/
#include <iostream>
enum CarTypeTag {
    BM,
    AD,
    JK
};

class Car {
public:
    virtual void drive() = 0;
};

class BMCar : public Car {
public:
    void drive() override {
        std::cout << "bmCar is dirving" << std::endl;
    }
};

class ADCar : public Car {
public:
    void drive() override;
};

class JKCar : public Car {
public:
    void drive() override;
};

//工厂类
class Factory {
public:
    Factory() {}

    Car* createCar(CarTypeTag type) {
        switch (type)
        {
        case BM:
            return new BMCar();
            break;
        case AD:
            return new ADCar();
            break;
        case JK:
            return new JKCar();
            break;
        default:
            return nullptr;
            break;
        }
    }
};

int main() {
    Factory factory;
    Car* bmCar = factory.createCar(BM);
    bmCar->drive();
    return 0;
}
```

### 工厂方法模式

其实这才是正宗的工厂模式，简单工厂模式只是一个简单的对创建过程封装。

工厂方法模式在简单工厂模式的基础上增加对**工厂的基类抽象**，不同的产品创建采用不同的工厂创建（从工厂的抽象基类派生），这样创建不同的产品过程就由不同的工厂分工解决：FactoryA专心负责生产ProductA，FactoryB专心负责生产ProductB，FactoryA和FactoryB之间没有关系；如果到了后期，如果需要生产ProductC时，我们则可以创建一个FactoryC工厂类，该类专心负责生产ProductC类产品。

```cpp
class Factory {
public:
    virtual Car* createCar() = 0;
};

class BMFactory: public Factory {
public:
    Car* createCar() {
        return new BMCar();
    }
};

class ADFactory: public Factory {
public:
    Car* createCar() {
        return new ADCar();
    }
};

class JKFactory: public Factory {
public:
    Car* createCar() {
        return new JKCar();
    }
};
```

### 抽象工厂模式

抽象工厂模式对工厂方法模式进行了更加一般化的描述。工厂方法模式适用于产品种类结构单一的场合，为一类产品提供创建的接口；而抽象工厂方法适用于产品种类结构多的场合，就是当具有多个抽象产品类型时，抽象工厂便可以派上用场。

抽象工厂模式更适合实际情况，受生产线所限，让低端工厂生产不同种类的低端产品，高端工厂生产不同种类的高端产品。

chatgpt:
```cpp
class AbstractProductA {
public:
    virtual void use() = 0;
};

class ConcreteProductA1 : public AbstractProductA {
public:
    void use() override {
        // Implementation for Product A1
    }
};

class ConcreteProductA2 : public AbstractProductA {
public:
    void use() override {
        // Implementation for Product A2
    }
};

class AbstractProductB {
public:
    virtual void use() = 0;
};

class ConcreteProductB1 : public AbstractProductB {
public:
    void use() override {
        // Implementation for Product B1
    }
};

class ConcreteProductB2 : public AbstractProductB {
public:
    void use() override {
        // Implementation for Product B2
    }
};

class AbstractFactory {
public:
    virtual AbstractProductA* createProductA() = 0;
    virtual AbstractProductB* createProductB() = 0;
};

class ConcreteFactory1 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ConcreteProductA1();
    }

    AbstractProductB* createProductB() override {
        return new ConcreteProductB1();
    }
};

class ConcreteFactory2 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ConcreteProductA2();
    }

    AbstractProductB* createProductB() override {
        return new ConcreteProductB2();
    }
};

```