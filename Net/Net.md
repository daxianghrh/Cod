# 计算机网络相关问题

## 1、常见HTTP状态码

-   `2xx`：表示服务器成功处理客户端请求
    -   [200 OK]:一切正常
    -   [204 NO Content]:与200 OK基本相同，但响应头无`body`数据
-   `3xx`: 表示客户端用新的URL重新发送请求获取资源，**重定向**
-   `4xx`: 客户端报文有误
    
    -   [404 Not Found]: 请求的资源在服务器中找不到或未找到
-   `5xx`: 客户端正常，**服务器处理时内部发生错误**。

## 2、HTTP常见字段有哪些？

-   `Host`字段: 指定服务器域名，www.baidu.com
-   `Content-Length`字段：服务器返回数据，指明本次回应的数据长度
-   `Connection`字段：用于客户端要求服务器使用TCP长久连接，HTTP/1.1默认持久连接
-   `Content-Type`字段：数据格式

## 3、GET与POST的区别？

-   `GET`：从服务器获取资源
-   `POST`:向URI提高资源数据，数据放在`body`中
-   `GET`是只读的，安全的、幂等的；`POST`反之。

## 4、HTTP协议的优缺点？

HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本（如HTML）的应用层协议。HTTP具有以下优点和缺点：

优点：
1. 简单易用：HTTP的设计简单明了，易于理解和实现。它使用简单的请求-响应模型，客户端发送请求，服务器返回响应，使得开发和调试变得相对容易。

2. 平台无关性：HTTP是与平台和操作系统无关的协议，可在不同的计算机和设备上进行通信。这使得不同平台之间的数据交换变得更加容易。

3. 灵活性：HTTP支持多种数据格式，包括文本、图像、音频、视频等。它还支持不同的请求方法（如GET、POST、PUT、DELETE等），使其适用于各种应用场景。

4. 可扩展性：HTTP是可扩展的协议，允许通过定义自定义的头部字段和扩展方法来满足特定的需求。这样可以实现更多的功能和特性，使协议更适应不同的应用需求。

缺点：
1. 无状态性：HTTP是无状态协议，每个请求都是独立的，服务器不会保留客户端的状态信息。这导致无法直接在多个请求之间共享上下文和状态，需要通过其他机制（如Cookie、Session）来实现状态管理。

2. 安全性较弱：HTTP的通信是明文传输的，数据在传输过程中容易被窃听、篡改和伪造。为了提供安全性，需要使用HTTPS（HTTP over SSL/TLS）等安全协议来加密和保护通信内容。

3. 性能较低：HTTP协议在传输过程中有较多的开销，如建立连接、发送请求头、等待响应等。对于大量并发请求和大数据传输，性能可能受到限制。

4. 无法保证可靠性：HTTP协议本身不具备数据传输的可靠性保证机制。如果在传输过程中发生错误或丢失，需要通过应用层的机制来处理和纠正。


## 5、HTTP/1.1性能如何？

-   HTTP/1.0，客户端每发送一次请求，就会产生一次TCP连接(TCP三次握手)，而且是串行请求；HTTP/1.1提出了**长连接**通信方式。
-   管道网络传输：客户端多次发送请求，不必等待上次请求回应返回。
-   队头堵塞

## 6、HTTP与HTTPS的区别？

HTTP（Hypertext Transfer Protocol）和HTTPS（HTTP Secure）是用于在网络上传输数据的协议，它们之间存在以下区别：

1. 安全性：
   - HTTP：HTTP是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。因此，对于敏感信息的传输，如用户密码、信用卡信息等，使用HTTP不安全。
   - HTTPS：HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议来加密HTTP通信，确保数据在传输过程中的机密性和完整性。通过使用证书进行身份验证，HTTPS还提供了对服务器身份的验证，防止中间人攻击。

2. 通信端口：
   - HTTP：默认使用端口80进行通信。
   - HTTPS：默认使用端口443进行通信。

3. 协议底层：
   - HTTP：HTTP运行在TCP/IP协议之上。
   - HTTPS：HTTPS是在HTTP协议基础上添加了SSL/TLS层来加密通信。SSL/TLS层位于传输层和应用层之间，对传输的数据进行加密和解密处理。

4. URL前缀：
   - HTTP：URL以`http://`开头。
   - HTTPS：URL以`https://`开头。

5. 证书：
   - HTTP：不需要证书。
   - HTTPS：使用SSL/TLS证书进行身份验证和加密通信。证书由可信任的第三方机构颁发，用于验证服务器的身份和建立安全通信。

6. 性能：
   - HTTP：由于没有加密和认证的开销，HTTP的性能通常比HTTPS更高。
   - HTTPS：由于加密和认证的开销，HTTPS比HTTP稍微慢一些。但是，随着计算机硬件和网络技术的发展，HTTPS的性能已经得到了改进，并且被广泛应用于保护敏感数据的通信。

总之，HTTP和HTTPS是用于在网络上传输数据的两种协议。HTTP是明文传输协议，适用于一般的数据传输，而HTTPS通过加密和身份验证提供了更高的安全性，适用于敏感信息的传输。选择使用HTTP还是HTTPS取决于数据的敏感性和安全要求。在处理用户敏感信息、进行支付、登录等场景下，使用HTTPS是必要的。


## 7、说一下HTTP/1.1,HTTP/2,HTTP/3的区别与优缺点

HTTP/1.1、HTTP/2和HTTP/3是HTTP协议的不同版本，它们之间有以下区别和各自的优缺点：

1. HTTP/1.1：
   - 特点：HTTP/1.1是最早的版本，采用文本格式传输数据。每个请求和响应都需要建立独立的连接，请求和响应的处理是串行的。
   - 优点：
     - 兼容性：广泛被服务器和客户端支持，具有良好的兼容性。
     - 简单易用：实现简单，易于理解和调试。
   - 缺点：
     - 队头阻塞：串行处理请求和响应，容易出现队头阻塞问题，一个请求的处理阻塞了后续请求的处理。
     - 性能限制：每个请求都需要建立独立的连接，造成了较高的延迟和开销。
     - 无法充分利用带宽：每个请求和响应都需要携带完整的头部信息，增加了数据传输的开销。

2. HTTP/2：
   - 特点：HTTP/2引入了二进制协议，使用二进制格式传输数据，并通过多路复用技术在单个连接上同时处理多个请求和响应。
   - 优点：
     - 多路复用：通过多路复用技术，在同一个连接上并行处理多个请求和响应，提高了效率和性能。
     - 头部压缩：引入了头部压缩机制，减少了数据传输的开销。
     - 服务器推送：服务器可以主动推送资源给客户端，减少了客户端请求的延迟。
   - 缺点：
     - 部署复杂性：相对于HTTP/1.1，部署和配置HTTP/2的服务器和客户端需要更多的工作。
     - 版本兼容性：旧的服务器和客户端可能不支持HTTP/2，需要进行升级或者回退到HTTP/1.1。

3. HTTP/3：
   - 特点：HTTP/3基于UDP协议的QUIC（Quick UDP Internet Connections）协议，使用新的传输层协议来实现更快的连接建立和可靠的数据传输。
   - 优点：
     - 快速连接建立：QUIC协议具有快速的连接建立能力，减少了连接建立的延迟。
     - 抗丢包能力：基于UDP协议的QUIC可以更好地应对丢包和网络抖动，提供更可靠的数据传输。
     - 多路复用：类似于HTTP/2，HTTP/3也支持多路复用，同时处理多个请求和响应。
   - 缺点：
     - 版本兼容性：由于HTTP/3基于QUIC协议，与传统的HTTP/1.1和HTTP/2相比，对现有网络基础设施和中间设备的兼容性有一定挑战。

需要注意的是，选择使用哪个版本取决于具体的应用需求和环境。HTTP/1.1适用于简单的请求-响应场景，HTTP/2适用于对并发性能有要求的场景，而HTTP/3适用于要求更快的连接建立和可靠数据传输的场景。在实际使用时，应综合考虑协议特性、应用需求和网络环境来进行选择。
## 8、tcp三次握手，accept对应三次握手中的哪一次？

`TCP`服务端和客户端连接模型如下所示：

![](../image/tcp连接图.png)

`accept`应该位于第三次握手之后，我们来看看`TCP`连接过程：

-   初始：客户端处于CLOSED状态，而服务器端从CLOSED状态变为LISTEN状态

-   第一步：客户端发送一个SYN序列号

-   第二步：服务器端接收来自客户端的连接请求，并返回ACK+SYN

-   第三步：客户端接收消息，返回ACK

-   第三步之后，服务器接收到消息，连接就完成了。这样就可以调用`accept`函数获得此连接。

accept其实也可以在第三步，原因是，此时accept函数要给此次连接分配资源，最初是想这样设计；但是，设想如果有10000甚至更多个客户端都和该服务器连接，发送SYN，服务端收到之后，这些客户端却不再理会服务端的回复，然而此时服务端的资源却都用accept()分配了。这就是所谓的DDOS攻击。

为了解决这个问题，**`accept()`于是被放在三次握手之后**。

## 9、为什么TIME_WAIT等待的时间是2MSL？

`MSL`,`Maximum Segment Lifetime`,报文最大生存时间，是报文在网络上存在的最长时间。因为`TCP`报文基于`IP`协议的，`IP`头中有一个`TTL字段`，是`IP`数据包可以经过的最大路由数，没经过一个路由减1，当值为0时将数据包丢弃，同时发送`ICMP`报文通知主机。

`TIME_WAIT`等于2倍的`MSL`，因为网络中可能存在来自发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间，比如`TCP`四次挥手过程中，服务端向客户端发送`FIN`报文，客户端需要向服务端相应`ACK`报文，若在`TIME_WAIT`时间内，`ACK`报文未传输到服务端，那么将重新计时。

注：TCP通信中主动关闭连接的，才会有TIME_WAIT状态。

## 10、为什么需要TIME_WAIT状态呢？

-  防⽌具有相同「四元组」的「旧」数据包被收到；
-  保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；

## 11、TIME_WAIT过多有什么危害？

-  服务器端存在过多TIME_WAIT：
   -  内存资源的占用
   -  对端口资源的占用，一个TCP连接至少消耗一个本地端口
-  客户端：
   -  占满所有端口资源，则会导致无法创建新连接

## 12、如果已经建立了连接，但是客户端突然出现故障了怎么办？

`TCP`有一个机制是**保活机制**，定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀个时间间隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。

## 13、计算机网络模型？七层和四层？

计算机网络模型是一种用于描述和组织计算机网络通信的结构化方式。常见的网络模型有 OSI（开放系统互联）、TCP/IP（传输控制协议/互联网协议）等。其中，TCP/IP 模型是实际应用最广泛的网络模型，下面对 OSI 模型和 TCP/IP 模型进行简要介绍：

1. **OSI 模型（Open Systems Interconnection Model）：**
   OSI 模型是一种七层分层模型，每一层都代表着网络通信中的不同功能。这些层按照从下到上的顺序分别是：
   1. 物理层（Physical Layer）：传输比特流，控制电压、电流等物理特性。
   2. 数据链路层（Data Link Layer）：处理数据帧的传输，错误检测和修复。
   3. 网络层（Network Layer）：实现路由和转发，处理数据包的路由选择。
   4. 传输层（Transport Layer）：为两台主机之间的通信提供端到端的通信服务，如分段、流量控制等。
   5. 会话层（Session Layer）：管理会话，建立、维护、终止连接。
   6. 表示层（Presentation Layer）：数据格式转换、数据加解密、数据压缩等。
   7. 应用层（Application Layer）：为用户提供应用服务，如文件传输、电子邮件等。

2. **TCP/IP 模型：**
   TCP/IP 模型是一种四层模型，它是实际互联网通信中最常用的模型。这些层从下到上分别是：
   1. 网络接口层（Network Interface Layer）：与物理硬件交互，包括网卡驱动、MAC地址等。
   2. 互联网层（Internet Layer）：处理 IP 地址、路由和数据包传递，包括 IP 协议和路由协议。
   3. 传输层（Transport Layer）：提供端到端的通信服务，如 TCP 和 UDP 协议。
   4. 应用层（Application Layer）：为用户提供各种应用服务，如 HTTP、FTP、SMTP 等。

需要注意的是，TCP/IP 模型的应用层涵盖了 OSI 模型中的会话层、表示层和应用层，将它们合并在一起。

## 14、TCP连接中拔掉网线会怎么样？

在一个正常的 TCP 连接中，如果突然拔掉了网络线，会导致以下情况：

1. **连接中断：** 当拔掉网络线时，网络连接会立即中断，导致连接的两端无法继续进行通信。

2. **发送数据失败：** 如果在拔掉网络线之前有正在发送的数据，那么这些数据的发送将会失败，因为无法通过断开的连接传输。

3. **发送 RST 包：** 拔掉网络线会导致连接中断，其中一端会立即发送一个称为 RST（重置）的 TCP 包给另一端，以通知对方连接已经关闭。

4. **连接状态处理：** 通常，连接的两端的操作系统会在连接中断时收到一个事件，从而可以处理连接中断的情况。这可能包括释放连接资源、触发异常处理程序等。

5. **连接恢复：** 如果在拔掉网络线之后又重新连接了网络线，通常情况下，连接是不会自动恢复的。需要重新建立连接，这可能需要应用程序重新尝试建立连接或者依赖于网络协议的一些机制来进行连接的重试。

## 15、TCP连接为什么是3次握手？不是两次、四次？

- 可以阻止重复历史连接的初始化(主要原因):网络环境复杂多变，可能会出现旧的连接数据包比新的连接数据包提前到达，客户端发现回应的`ACK Num`不对，重新发送`RST`,不进行连接。
   -  如果是2次握手，不能判断是否是历史连接。
   -  3次握手已经理论可以进行可靠连接建立，所以不需要使用4次。
-  同步双方初始序列号

-  避免资源浪费

## 16、TCP连接断开需要4次挥手？

-  关闭连接时，客户端向服务端发送FIN时，仅仅表示客户端不再发送数据了但是还能接收数据。

-  服务器收到客户端的FIN报⽂时，先回⼀个ACK应答报⽂，⽽服务端可能还有数据需要处理和发送，等务端不再发送数据时，才发送FIN报⽂给客户端来表示同意现在关闭连接。

## 17、TCP socket编程中如何来限制一个socket的访问连接的最大数量?

在TCP socket编程中，您可以使用以下方法来限制一个socket的访问连接的最大数量：

1. **使用`listen`函数的第二个参数**：
   - 在服务器端程序中，可以使用`listen`函数来指定服务器可以接受的最大连接数量。`listen`函数通常如下使用：
   
     ```c
     int listen(int sockfd, int backlog);
     ```

     其中，`sockfd`是服务器套接字的文件描述符，而`backlog`参数用于指定等待连接队列的最大长度。这个参数限制了等待连接的客户端数量。如果超过这个数量，新的客户端连接请求将被拒绝。请注意，`backlog`的具体值取决于操作系统和系统配置。

2. **使用操作系统的资源限制**：
   
- 您还可以使用操作系统提供的资源限制来控制socket连接的数量。例如，在Linux系统中，可以使用`ulimit`命令来设置进程的资源限制，其中包括同时打开的文件描述符数量。这将影响可以创建的socket连接数量。
   
3. **手动跟踪连接数量**：
   
   - 您可以在服务器端代码中维护一个计数器，用于跟踪当前连接的数量。每当有新的连接建立或连接关闭时，更新计数器的值。当达到最大连接数量时，拒绝新的连接请求。

## 18、TCP传输过程中传输的数据不是期望数据怎么解决？

在TCP传输过程中，如果接收方收到的数据不是期望的数据，可能是因为数据包丢失、数据包乱序或者网络中的其他问题导致的。为了解决这些问题，您可以采取以下一些方法：

1. **重传丢失的数据包**：
   - 如果接收方检测到丢失的数据包，它可以通知发送方重新发送丢失的数据包。TCP协议本身会自动处理这个问题，因为它具有重传机制。如果接收方在一定时间内没有收到特定数据包的确认，发送方将会重新发送该数据包。

2. **按序处理乱序数据包**：
   - 如果数据包因为网络延迟或拥塞而乱序到达，接收方可以按照数据包的序列号将它们正确排序。TCP协议会确保数据包按照正确的顺序交付给应用程序。

3. **使用应用层协议进行数据验证**：
   - 您可以在应用层实现数据验证和恢复机制。例如，您可以在数据包中包含校验和或CRC，以检测数据包的完整性。如果接收方检测到损坏的数据包，可以请求重新传输。

4. **超时和重传策略的调整**：
   - 在某些情况下，网络条件可能不稳定，导致数据包丢失或延迟。调整TCP的超时和重传策略可以改善数据传输的可靠性。这可以在操作系统或应用程序级别进行配置。

5. **记录和调试**：
   - 对于问题的诊断和解决，记录传输过程中的数据包和事件是非常有帮助的。使用网络分析工具（例如Wireshark）可以帮助您监视和分析TCP数据传输，以找出问题的原因。

6. **使用可靠的应用层协议**：
   - 如果数据的可靠性对您的应用程序至关重要，可以考虑使用基于TCP的可靠的应用层协议，例如HTTP或FTP。这些协议已经实现了许多数据可靠性的特性，可以减少您自行处理的工作。

总之，TCP协议本身提供了许多机制来处理数据传输中的问题，但在特定情况下，可能需要在应用层添加额外的逻辑来确保数据的可靠性和正确性。同时，监视和记录网络通信以及合理调整协议参数也是解决问题的关键步骤。

## 19、IP层分片怎么保证有序？IP头部结构？IP层分片后的数据包拼接是怎么拼接的？然后保证接收到的数据包在拼接后是属于一个响应的？

IP层分片是在网络传输过程中将较大的IP数据包分割成更小的片段（分片）以便于传输。这些分片可能会经过不同的网络路径到达目标，因此在目标主机上需要进行重新组装以还原原始的数据包。下面是有关IP分片、IP头部结构和数据包重组的一些详细信息：

**IP分片**：

1. **IP头部结构**：IPv4数据包的头部通常包括版本号、头部长度、服务类型、总长度、标识、标志、片偏移、生存时间、协议、头部校验和、源IP地址、目标IP地址等字段。其中，标志和片偏移字段用于标识和排序分片。

2. **分片过程**：当一个IP数据包太大以适应网络链路的最大传输单元（MTU）时，路由器可以将数据包分割成多个较小的分片。每个分片都有自己的IP头部，并在标志和片偏移字段中指示其在原始数据包中的位置。

3. **重新组装**：在目标主机上，接收到的分片会根据标识字段（Identification）来识别它们属于同一个原始数据包。然后，它们按照片偏移字段的值进行排序，重新组装成原始的数据包。

**保证有序性**：

IP分片和重新组装是网络层的功能，它只保证分片在目标主机上正确地重新组装成原始数据包，但不保证传输层以上的数据的有序性。为了确保上层协议（如TCP）接收到的数据包是有序的，通常需要在传输层（或应用层）进行处理：

1. **TCP序号（Sequence Number）**：在TCP协议中，每个TCP数据包都有一个序号字段，用于指示数据包在数据流中的位置。TCP协议负责确保数据包的有序传输。如果IP层分片导致TCP数据包的乱序，TCP协议会根据序号字段将它们重新排序。

2. **UDP等其他协议**：对于无连接的协议（如UDP），应用程序需要自行处理数据包的有序性，因为UDP不提供数据包的有序保证。

总之，IP层分片只负责分割和重新组装数据包，但不提供数据包的有序性保证。有序性通常由上层协议（如TCP）来实现，它们会使用序号字段来确保接收到的数据包按照正确的顺序传递给应用程序。如果IP层分片导致乱序，传输层协议会负责重新排序。

## 20、 假设有一个文件`300MB`，使用`TCP`传输需要多少秒？

要确定一个`300MB`文件使用TCP传输需要多少秒，你需要考虑多个因素，包括网络带宽、网络延迟和网络拥塞等。TCP传输速度取决于这些因素的组合。以下是一个简单的计算方式，假设网络没有拥塞，带宽足够，延迟很小：

1. 首先，你需要知道网络的带宽，通常以Mbps（兆比特每秒）或Gbps（千兆比特每秒）为单位。带宽表示每秒可以传输的比特数。

2. 将文件大小从兆字节（MB）转换为比特（bits）。1字节等于8比特。

3. 使用以下公式来计算传输时间：

   传输时间（秒） = 文件大小（比特） / 带宽（比特每秒）

   请注意，这是一个理论计算，不考虑网络延迟、丢包等因素。实际传输时间可能会更长。

例如，如果你的网络带宽为100Mbps，将300MB的文件传输到另一台计算机上，计算如下：

1. 文件大小：300MB = 300 * 8 = 2400兆比特（Mb）
2. 带宽：100Mbps = 100兆比特每秒（Mb/s）
3. 传输时间：2400 Mb / 100 Mb/s = 24秒

根据这个简单的计算，传输一个300MB的文件到一个100Mbps的网络链接大约需要24秒，但请记住，实际传输时间可能会因网络条件、拥塞和其他因素而有所不同。